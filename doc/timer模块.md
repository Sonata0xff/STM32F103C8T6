timer模块讲解：
1.利用更新中断的定时器：
    (1)该功能默认以STM32F103C8T6的TIM2定时器为资源进行定时
    (2)涉及的函数：
        1.void TimerInit(void); //该函数对定时器进行初始化操作
        2.void Delay_xus(uint16_t us); //该函数进行微秒级定时，仅支持大于3us的整数定时
        3.void Delay_xms(uint16_t ms); //该函数进行毫秒级定时，仅支持大于等于1ms的整数定时
        4.void TIM2_IRQHandler(void); //TIM2定时器的更新中断处理函数
    (3)该功能的调用方法：
        1.TimerInit(); //初始化定时器
        2.Delay_xus(n);//阻塞运行该函数的线程n微秒
        3.Delay_xms(n);//阻塞运行该函数的线程n毫秒


2.无需更新中断的定时器：
    (1)该功能默认以STM32F103C8T6的TIM2定时器为资源进行定时
    (2)涉及的函数：
        1.void TimerInitWithOutIT(void); //该函数对定时器进行初始化操作
        2.void Delay_xus_wit(uint16_t us); //该函数对定时器进行微秒级定时，仅支持大于等于1us的整数定时，并且有大约+0.1~+0.3us的定时误差
        3.void Delay_xms_wit(uint16_t ms); //该函数对定时器进行毫秒级定时，仅支持大于等于1ms的整数定时
    (3)该功能的调用方法：
        1.TimerInitWithOutIT(); //初始化定时器
        2.Delay_xus_wit(n); //阻塞当前线程n微秒
        3.Delay_xms_wit(n); //阻塞当前线程n毫秒

3.定时器原理分析：
(1)对于TimerInit函数而言，分为三个阶段：
    1.APB总线初始化
    2.定时器配置
    3.中断初始化
其中，
    (1)定时器初始化：
        1.设置SMCR寄存器的SMS位，来配置驱动时钟为内部时钟，频率为72Mhz
        2.设置CR1寄存器的CKD位，配置时钟分频因子来配置滤波器相关内容
        3.设置CR1寄存器的URS位，让其忽略除计数器溢出以外的其他方式引起的更新中断。
        4.设置CR1寄存器的DIR位，来配置向上计数还是向下计数。
        5.设置DIER寄存器的UIE位，来决定在产生更新事件时是否发起更新中断。如果设置UIE位，当更新事件产生时会设置更新标志位UIF，该位由软件复位。
        6.设置PSC寄存器，该寄存器用于存储预分频值，通常为实际分频值减一
        7.设置CR1的ARPE位，来启用相关寄存器的缓冲写入功能。该功能是为了防止在类似计数器，预分频器等寄存器在被使用时修改，启用该位后，每当修改相关寄存器的值，并不会立即更新到对应寄存器上，而是写入对应缓冲区，等到更新事件产生时再将所有值写入到对应寄存器中。
        8.设置CR1的UDIS位来允许产生更新事件。不设置该位将导致所有寄存器的值不变化，以及不产生更新事件。
        9.设置EGR寄存器的UG位，该位置1将软件产生更新事件，而硬件负责复位。
    (2)更新事件UEV：
        在发生更新事件时，会将所有的缓冲区数据写入到对应寄存器中，以及根据URS位来判断是否应该产生更新中断。

(2)对于Delay_xus函数而言分为三阶段：
    1.配置定时时长
    2.启动定时器，并判断是否计时完毕
    3.关闭定时器
其中，
    (1)配置定时时长：
        1.TimeTag置0，这个为标志位，当定时器定时完成后会在中断函数内将该位置1来告诉软件定时完成。
        2.设置PSC的数值为72-1，及代表配置频率为1Mhz
        3.配置ARR寄存器数值为us-3，其中us-1代表对寄存器的配置为实际时长-1，而-2则代表外部配置耗时2us
        4.配置EGR的UG位软件产生更新事件，将刚刚写入缓冲区的内容刷入寄存器中
        5.设置CR1寄存器的CEN位，启动定时器。
    (2)启动定时器，并判断是否计时完毕
        这里使用while循环来检测定时器是否将TimeTag_置1，如果置1代表定时完成，否则继续等待
    (3)关闭定时器：
        将CR1的CEN位置为0关闭定时器。

(3)对于毫秒级定时原理相同区别在于预分频配置
(4)对于无需中断的定时功能而言配置基本与需要中断的类似，以下仅说明区别：
    1.无需中断的定时功能初始化时不需要配置中断，不需要中断处理函数，不需要TimeTag_标志位
    2.无需中断的定时功能初始化时将设置UIE位为0，来关闭更新中断。
    3.在延时函数中，无需中断的定时功能不再关注TimeTag_，而是关注CNT寄存器hi否达到要求的计数次数。

4.关于一些定时器的总结：
    (1)定时器溢出的本质是定时器达到指定计数后会跳转至0，然后才会产生更新事件与更新中断，这就是为什么配置ARR时定时是us-1，而不是us本身.
    
    (2)产生更新事件UEV时，会将所有缓冲区内容刷入对应寄存器。

    (3)CR1的UDIS位决定是否产生更新事件UEV

    (4)DIER的UIE位决定是否产生更新中断

    (5)CR1的URS位决定是否除定时器溢出外其他手段产生更新事件时，是否产生更新中断

    (6)CR1的CEN位决定定时器的启停

    (7)将缓冲区内容刷入寄存器的两个步骤：
        1.EGR寄存器ARPE位置位来启用缓冲功能(无需重复设置)
        2.EGR寄存器UG位置位来软件产生更新事件，将缓冲区内容刷入对应寄存器中
    
    (8)PSC寄存器用于存储预分频

    (9)CR1的DIR位决定计时方向

    (10)CR1寄存器的ARPE位决定是否启用寄存器的缓冲写入区功能
