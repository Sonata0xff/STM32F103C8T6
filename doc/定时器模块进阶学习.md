1.基本定时功能：
    设置定时器定时固定时间，定时到将触发中断，并重装定时器。无输入输出
(1)定时器总体结构：
    /*待补充*/
(2)基本定时配置：
    /*待补充*/
(3)样例代码：在该代码中初始化PA0位推挽输出，PA0外接LED灯。使用定时器1循环定时10ms，定时到则通过中断来改变LED灯状态。
    /*GPIO outport init*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitTypeDef gpioA0_config = {
		.GPIO_Pin = GPIO_Pin_0,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_Out_PP
	};
	GPIO_Init(GPIOA, &gpioA0_config);
	GPIO_ResetBits(GPIOA, GPIO_Pin_0);
	/*TIMER1 Init base count 10ms*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	TIM_InternalClockConfig(TIM1);
	TIM_TimeBaseInitTypeDef tim1_config = {
		.TIM_Prescaler = 71,
		.TIM_CounterMode = TIM_CounterMode_Up,
		.TIM_Period = 10000,
		.TIM_ClockDivision = TIM_CKD_DIV2,
		.TIM_RepetitionCounter = 0
	};
	TIM_TimeBaseInit(TIM1, &tim1_config);
	TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);
	/*NVIC config*/
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_InitTypeDef tim1_func_config = {
		.NVIC_IRQChannel = TIM1_UP_IRQn,
		.NVIC_IRQChannelPreemptionPriority = 1,
		.NVIC_IRQChannelSubPriority = 1,
		.NVIC_IRQChannelCmd = ENABLE
	};
	NVIC_Init(&tim1_func_config);
	/*Start timer*/
	TIM_Cmd(TIM1, ENABLE);
	
	while(1);
    此外，中断函数定义：
    void TIM1_UP_IRQHandler()
    {
        if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_0)) GPIO_ResetBits(GPIOA, GPIO_Pin_0);
        else GPIO_SetBits(GPIOA, GPIO_Pin_0);
        TIM_ClearITPendingBit(TIM1, TIM_IT_Update);
    }













(4)样例代码二：输入捕获，当频率等于1KHz时，亮起PA0连接的LED，否则熄灭
	/*GPIO outport init*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitTypeDef gpioA0_config = {
		.GPIO_Pin = GPIO_Pin_0,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_Out_PP
	};
	GPIO_Init(GPIOA, &gpioA0_config);
	GPIO_SetBits(GPIOA, GPIO_Pin_0);
	/*GPIO remap inputport init*/
	GPIO_InitTypeDef input_port_config = {
		.GPIO_Pin = GPIO_Pin_8,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_IN_FLOATING
	};
	GPIO_Init(GPIOA, &input_port_config);
	/*TIM1 init*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	TIM_InternalClockConfig(TIM1);
	TIM_TimeBaseInitTypeDef base_config = {
		.TIM_Prescaler = 71,
		.TIM_CounterMode = TIM_CounterMode_Up,
		.TIM_Period = 10000,
		.TIM_ClockDivision = TIM_CKD_DIV2,
		.TIM_RepetitionCounter = 0
	};
	TIM_TimeBaseInit(TIM1, &base_config);
	TIM_ICInitTypeDef ic_config = {
		.TIM_Channel = TIM_Channel_1,
		.TIM_ICPolarity = TIM_ICPolarity_Rising,
		.TIM_ICSelection = TIM_ICSelection_DirectTI,
		.TIM_ICPrescaler = TIM_ICPSC_DIV1,
		.TIM_ICFilter = 1
	};
	TIM_ICInit(TIM1, &ic_config);
	TIM_ITConfig(TIM1, TIM_IT_CC1, ENABLE);
	/*NVIC init*/
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_InitTypeDef nvic_config = {
		.NVIC_IRQChannel = TIM1_CC_IRQn,
		.NVIC_IRQChannelPreemptionPriority = 1,
		.NVIC_IRQChannelSubPriority = 1,
		.NVIC_IRQChannelCmd = ENABLE
	};
	NVIC_Init(&nvic_config);
	/*Start func*/
	
	TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
	TIM_Cmd(TIM1, ENABLE);


	中断函数配置：
	void TIM1_CC_IRQHandler()
	{
		uint16_t val = TIM_GetCapture1(TIM1);
		if (val == 1000 - 1 || val == 1000) GPIO_SetBits(GPIOA, GPIO_Pin_0);
		else GPIO_ResetBits(GPIOA, GPIO_Pin_0);
		TIM_SetCounter(TIM1, 0x0000);
		TIM_ClearITPendingBit(TIM1, TIM_IT_CC1);
	}

















(5)样例代码三：非终端输入捕获。频率为1Khz时，亮起PA0连接的LED，否则熄灭，比中断方案更加精准，使用从模式TIx触发实现
	/*GPIO outport init*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitTypeDef gpioA0_config = {
		.GPIO_Pin = GPIO_Pin_0,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_Out_PP
	};
	GPIO_Init(GPIOA, &gpioA0_config);
	GPIO_SetBits(GPIOA, GPIO_Pin_0);
	/*GPIO remap inputport init*/
	GPIO_InitTypeDef input_port_config = {
		.GPIO_Pin = GPIO_Pin_8,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_IN_FLOATING
	};
	GPIO_Init(GPIOA, &input_port_config);
	/*TIM1 init*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	TIM_InternalClockConfig(TIM1);
	TIM_TimeBaseInitTypeDef base_config = {
		.TIM_Prescaler = 71,
		.TIM_CounterMode = TIM_CounterMode_Up,
		.TIM_Period = 10000,
		.TIM_ClockDivision = TIM_CKD_DIV2,
		.TIM_RepetitionCounter = 0
	};
	TIM_TimeBaseInit(TIM1, &base_config);
	TIM_ICInitTypeDef ic_config = {
		.TIM_Channel = TIM_Channel_1,
		.TIM_ICPolarity = TIM_ICPolarity_Rising,
		.TIM_ICSelection = TIM_ICSelection_DirectTI,
		.TIM_ICPrescaler = TIM_ICPSC_DIV1,
		.TIM_ICFilter = 1
	};
	TIM_ICInit(TIM1, &ic_config);
	TIM_SelectInputTrigger(TIM1, TIM_TS_TI1FP1);
	TIM_SelectSlaveMode(TIM1, TIM_SlaveMode_Reset);
	/*Start func*/
	TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
	TIM_Cmd(TIM1, ENABLE);
	while(1) {
		if (TIM_GetFlagStatus(TIM1, TIM_FLAG_Trigger) == RESET) continue;
		else TIM_ClearFlag(TIM1, TIM_FLAG_Trigger);
		if (TIM_GetCapture1(TIM1) == 1000) GPIO_SetBits(GPIOA, GPIO_Pin_0);
		else GPIO_ResetBits(GPIOA, GPIO_Pin_0);
	}
	






(6)样例代码四：输出比较功能。输出一个固定的PWM波形到PA8，其中timer_period_us为周期长，emp_percent为占空比。
	/*get pwm value*/
	uint16_t timer_period_us = 1000;
	float emp_precent = 0.5;
	uint16_t wholePeriod = (uint16_t)(timer_period_us / 2);
	uint16_t lowPeriod = (uint16_t)(wholePeriod * emp_precent);
	/*init outport gpio*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitTypeDef outport_config = {
		.GPIO_Pin = GPIO_Pin_8,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_AF_PP
	};
	GPIO_Init(GPIOA, &outport_config);
	/*init timer1*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	TIM_InternalClockConfig(TIM1);
	TIM_TimeBaseInitTypeDef base_config = {
		.TIM_Prescaler = 72 - 1,
		.TIM_CounterMode = TIM_CounterMode_CenterAligned1,
		.TIM_Period = wholePeriod,
		.TIM_ClockDivision = TIM_CKD_DIV2,
		.TIM_RepetitionCounter = 0
	};
	TIM_TimeBaseInit(TIM1, &base_config);
	TIM_OCInitTypeDef oc_config = {
		.TIM_OCMode = TIM_OCMode_Toggle,
		.TIM_OutputState = TIM_OutputState_Enable,
		.TIM_OutputNState = TIM_OutputNState_Disable,
		.TIM_Pulse = lowPeriod,
		.TIM_OCPolarity = TIM_OCPolarity_High,
		.TIM_OCNPolarity = TIM_OCNPolarity_High,
		.TIM_OCIdleState = TIM_OCIdleState_Reset,
		.TIM_OCNIdleState = TIM_OCNIdleState_Reset
	};
	TIM_CtrlPWMOutputs(TIM1, ENABLE);
	TIM_OC1Init(TIM1, &oc_config);
	/*start system*/
	TIM_Cmd(TIM1, ENABLE);
	while(1);
	return 0;



(7)样例代码五：编码器功能。其中PA8做ti1输入，PA9做ti2输入，输入为方波信号，ti2滞后半个周期。此代码将驱动计数器向上计数到1000时，修改PA0电平。
	/*init GPIO*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitTypeDef ti1_port = {
		.GPIO_Pin = GPIO_Pin_8,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_IN_FLOATING
	};
	GPIO_InitTypeDef ti2_port = {
		.GPIO_Pin = GPIO_Pin_9,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_IN_FLOATING
	};
	GPIO_InitTypeDef ex_port = {
		.GPIO_Pin = GPIO_Pin_0,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Mode = GPIO_Mode_Out_PP
	};
	GPIO_Init(GPIOA, &ti1_port);
	GPIO_Init(GPIOA, &ti2_port);
	GPIO_Init(GPIOA, &ex_port);
	/*timer init*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	TIM_EncoderInterfaceConfig(TIM1, TIM_EncoderMode_TI12, TIM_ICPolarity_BothEdge, TIM_ICPolarity_BothEdge);
	TIM_TimeBaseInitTypeDef base_config = {
		.TIM_Prescaler = 1 - 1,
		.TIM_CounterMode = TIM_CounterMode_Up,
		.TIM_Period = 1000 - 1,
		.TIM_ClockDivision = TIM_CKD_DIV2,
		.TIM_RepetitionCounter = 0
	};
	TIM_TimeBaseInit(TIM1, &base_config);
	/*start counter*/
	TIM_Cmd(TIM1, ENABLE);
	while(1) {
		if (TIM_GetFlagStatus(TIM1, TIM_FLAG_Update) == RESET) continue;
		TIM_ClearFlag(TIM1, TIM_FLAG_Update);
		if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_0) != 0) GPIO_ResetBits(GPIOA, GPIO_Pin_0);
		else GPIO_SetBits(GPIOA, GPIO_Pin_0);
	}
	return 0;